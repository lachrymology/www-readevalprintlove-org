<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>(λove (print (eval (read))))</title>
    <!--[if lt IE 9]>
	<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="icon" href="images/labyrinth.ico" type="image/x-icon">
    <link rel="shortcut icon" href="images/labyrinth.ico" type="image/x-icon" />

    <link rel="stylesheet" href="css/style.css" type="text/css">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="stylesheet" href="css/skeleton-responsive.css">
    <link rel="stylesheet" href="css/layout-responsive.css">

    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js?lang=lisp"></script>
  </head>

  <body class="home page page-id-9 page-template-default">
    <div class="body-wrapper">
      <div class="container">
	<div class="header-wrapper">
	  <div class="header-right-side-wrapper">
	    <div class="social-wrapper">
	      <div class="social-icon-wrapper">
		<div class="social-icon">
		  <a href="http://www.twitter.com/fogus">
		    <img src="images/twitter.png" alt="twitter">
	          </a>
		</div>
		<div class="social-icon">
		  <a href="http://blog.fogus.me/tag/readevalprintlove/feed/">
		    <img src="images/rss.png" alt="feed">
	          </a>
		</div>
		<div class="social-icon">
		  <a href="http://www.readevalprintlove.org/subscribe.html">
		  	SUBSCRIBE
		  </a>
		</div>		
	      </div>
	    </div>

	    <!-- Nav -->
	    <div class="navigation-wrapper">
	      <div id="main-superfish-wrapper" class="menu-wrapper">
		<ul id="menu-main" class="sf-menu sf-js-enabled sf-shadow">
		</ul>
	      </div>
	    </div>
	    <div class="clear"></div>
	  </div> <!-- header-right-side -->
	</div> <!-- header-wrapper -->

	<div class="content-wrapper ">
	  <div class="page-wrapper">
	    <div class="sixteen columns mb0">
	      <div class="slider-wrapper fullwidth">
		<div class="flexslider">
		  <ul class="slides">
		    <li style="width: 100%; float: left; margin-right: -100%; display: list-item;">
		      <img src="http://farm6.staticflickr.com/5493/9713109016_bd97038431_o.jpg" width="940" height="1383" alt="sakura_etegami">
		    </li>
		</ul>
		</div>
	      </div>
	    </div>
	    <div class="gdl-page-float-left">
	      <div class="gdl-page-item">
		<div class="sixteen columns ">
		  <div class="section-wrapper">
		    <h1 class="section-title"><i>Sakura</i></h1>
		    <div class="section-content">
		      
<h1 id="sakura">Sakura</h1>

<p><em>Read-Eval-Print-λove is a bi-monthly newsletter of original content and curation about the Lisp family of programming languages and little-languages.</em></p>

<p>One day the macrolyte approached the master macrologist
Pi Mu (πㇺ) and put forth a question:</p>

<blockquote>
  <p>Master, which Lisp is the greatest of all Lisps?</p>
</blockquote>

<p>Pi Mu looked at the macrolyte and, in a low tone, told him 
to meet him in the garden after the day's work was done and he would tell him the answer.</p>

<p>After a long day's toil<sup id="fnref:toil"><a href="#fn:toil" class="footnote">1</a></sup> the macrolyte did as Pi Mu instructed 
and met him at the entryway to the humble garden.  He 
immediately posed his question again:</p>

<blockquote>
  <p>Master, which Lisp is the greatest of all Lisps?</p>
</blockquote>

<p>In a careful manner Pi Mu then pointed at a patch of nearby sakura and said:</p>

<blockquote>
  <p>Look here at this patch of sakura.</p>

  <p>What a tall one that one.</p>

  <p>What a short one that one.</p>
</blockquote>

<p>The student was at once enlightened.</p>

<p>The theme of this installment of Read-Eval-Print-λove is: musings on the function, nature, differences and commonalities of the Lisp family of languages in general.</p>

<h1 id="dedication">Dedication</h1>

<p><img src="http://replove.herokuapp.com/images/jmc.jpg" alt="September 4, 1927 -- October 24, 2011" /></p>

<h1 id="whats-lisp">What's Lisp?</h1>

<p>In 1980 John McCarthy wrote a paper entitled <em><a href="http://www-formal.stanford.edu/jmc/lisp20th.html)">LISP - Notes on its past and future</a></em> for Stanford's Lisp conference that year.  With in the paper he listed fifteen points that he claimed characterized LISP, shown in-full below:</p>

<ol>
  <li>
    <p>Computing with symbolic expressions rather than numbers.</p>
  </li>
  <li>
    <p>Representation of symbolic expressions and other information by
list structure in computer memory.</p>
  </li>
  <li>
    <p>Representation of information on paper, from keyboards and in
other external media mostly by multi-level lists and sometimes by
S-expressions. It has been important that any kind of data can be 
represented by a single general type.</p>
  </li>
  <li>
    <p>A small set of selector and constructor operations expressed as
functions, i.e. <code>car</code>, <code>cdr</code> and <code>cons</code>.</p>
  </li>
  <li>
    <p>Composition of functions as a tool for forming more complex
functions.</p>
  </li>
  <li>
    <p>The use of conditional expressions for getting branching into
function definitions.</p>
  </li>
  <li>
    <p>The recursive use of conditional expressions as a sufficient tool
for building computable functions.</p>
  </li>
  <li>
    <p>The use of λ-expressions for naming functions.</p>
  </li>
  <li>
    <p>The storage of information on the property lists of atoms.</p>
  </li>
  <li>
    <p>The representation of LISP programs as LISP data that can be
manipulated by object programs. This has prevented the
separation between system programmers and application
    programmers. Everyone can <em>improve</em> his LISP, and many of 
    these <em>improvements</em> have developed into improvements to 
    the language.</p>
  </li>
  <li>
    <p>The conditional expression interpretation of Boolean
connectives.</p>
  </li>
  <li>
    <p>The LISP function <code>eval</code> that serves both as a formal 
definition of the language and as an interpreter.</p>
  </li>
  <li>
    <p>Garbage collection as the means of erasure.</p>
  </li>
  <li>
    <p>Minimal requirements for declarations so that LISP 
statements can be executed in an on-line environment <sup id="fnref:repl"><a href="#fn:repl" class="footnote">2</a></sup>
    without preliminaries.</p>
  </li>
  <li>
    <p>LISP statements as a command language in an on-line 
environment.</p>
  </li>
</ol>

<p>Under these conditions, what current languages are Lisps?  Which fall short? <sup id="fnref:more-lisp"><a href="#fn:more-lisp" class="footnote">3</a></sup></p>

<h2 id="related-reading">Related reading</h2>

<p>The following links explore the question:</p>

<blockquote>
  <p>What is a Lisp, and am I it?</p>
</blockquote>

<ul>
  <li><a href="http://www.defmacro.org/ramblings/lisp.html">The Nature of Lisp</a> by Slava Akhmechet</li>
  <li><a href="http://www.paulgraham.com/diff.html">What Made Lisp Different</a> by Paul Graham</li>
  <li><a href="http://www.randomhacks.net/articles/2005/12/03/why-ruby-is-an-acceptable-lisp">Why Ruby is an Acceptable Lisp</a> by Eric Kidd</li>
  <li><a href="http://steve-yegge.blogspot.com/2006/04/lisp-is-not-acceptable-lisp.html">Lisp is Not an Acceptable Lisp</a> by Steve Yegge</li>
  <li><a href="http://axisofeval.blogspot.com/2010/04/why-i-ignore-clojure.html">Why I Ignore Clojure</a> by Manuel Simoni</li>
  <li><a href="http://willwhim.wpengine.com/2013/02/22/why-scala-is-an-acceptable-lisp">Why Scala is an Acceptable Lisp</a> by Will Fitzgerald</li>
  <li><a href="http://web.archive.org/web/20051211071852/http://fresh.homeunix.net/files/ilc02/proceedings/Andre-van-Meulebrouck.pdf">Plotting and Scheming the Ubiquitous LISP</a> by AndrÃ© van Meulebrouck</li>
  <li><a href="http://stackoverflow.com/questions/323346/what-can-lisp-do-that-lua-cant">What can Lisp do that Lua can't?</a></li>
</ul>

<p>If you walk through this list focusing your lens of reason onto various programming languages then which ones make the cut?</p>

<p><img src="http://farm4.staticflickr.com/3757/9714346439_c1b802a549_o.png" width="295" height="250" alt="maybe"></p>

<p>One interesting consequence that falls out of adhering strictly to the list above is that those that meet many of the criteria tend to be little languages (another aspect I will explore from time to time).  For example, Lua<sup id="fnref:lua"><a href="#fn:lua" class="footnote">4</a></sup> meets many of the criteria above, but is it a Lisp?  Likewise, even Common Lisp falls short on at least one<sup id="fnref:std"><a href="#fn:std" class="footnote">5</a></sup> of McCarthy's criteria and many of the remaining points, while supported, are not considered central to â€œthe Common Lisp way.â€ <sup id="fnref:clway"><a href="#fn:clway" class="footnote">6</a></sup></p>

<h2 id="whos-lisp">Who's Lisp?</h2>

<p>Just because MacCarthy invented Lisp doesn't mean that he has the right to define what constitutes a Lisp.  This seems like a counter-intuitive thing to say, but the fact is that Lisp has grown far beyond anything that McCarthy imagined at the time that he defined the first <code>eval</code>.  Vendors, users, programmers, standards committees and implementers have a say also.</p>

<p><img src="http://farm4.staticflickr.com/3764/9714339415_6dc256e820_o.jpg" width="373" height="450" alt="naggum"></p>

<p>Pinning down what constitutes a Lisp based on McCarthy's list above is a tough task that is due to exclude many participants with partial (and often legitimate) claims to the feature set above. <sup id="fnref:scmnot"><a href="#fn:scmnot" class="footnote">7</a></sup>  On the other hand, simply taking an implementation like Common Lisp as the model of â€œLispinessâ€ is unsatisfactory as well since doing so excludes historical Lisps that fed into the development of the Common Lisp standard.  So maybe the right answer to â€œwhat is Lisp?â€ is simply -- â€œwho cares?â€<sup id="fnref:idont"><a href="#fn:idont" class="footnote">8</a></sup>  For the purposes of this zine<sup id="fnref:zine"><a href="#fn:zine" class="footnote">9</a></sup> I'll freely mix discussion and examples for various Lisp implementations both current and historical and not worry too much about identity issues.</p>

<h1 id="the-german-school-of-lisp-revisited">The German School of Lisp <sup id="fnref:revisited"><a href="#fn:revisited" class="footnote">10</a></sup></h1>

<p>Allow me to take a few moments to broadly segment the Lisp ecosystem into high-level categories, namely: Extension Lisps, Practical Lisps, Kernel Lisps and Lisps targeting education.</p>

<p>Of course, there are overlaps between these categories for any given Lisp instance, and you may not agree with certain placements or even the categories themselves.  That said, please humor me as I'm trying to establish a basis for an observation that there exist a category of Lisp-like languages that do not fall into any of these categories and in some ways cover them all -- blurring the line between the above categories while touching each, yet existing in a category that only exists by occlusion -- much like <a href="http://www.michaelbach.de/ot/cog_kanizsa/index.html">Kanizsa's Triangle</a>.</p>

<p><img src="http://replove.herokuapp.com/images/lisps.png" alt="Lisps" title="The space between" /></p>

<h2 id="exo-lisps">Exo-Lisps</h2>

<p>Exo-Lisps are the variants that exist to serve very pointed use cases.  They can take the form of highly specialized libraries or embeddables like the Scheme-based object system <a href="http://people.csail.mit.edu/gregs/ref-dyn-patterns.html">GLOS</a> or the graphics-rich programming language <a href="http://lush.sourceforge.net/">Lush</a>.</p>

<pre class="prettyprint lang-scm"><code>;; Using GLOS types and multiple dispatch to 
;; implement the Builder pattern (Sullivan 2002)
(add-method* convert
  (method ((builder &lt;tex-converter&gt;) (token &lt;char&gt;))
    . . . convert TeX character . . . )
  (method ((builder &lt;tex-converter&gt;) (token &lt;font&gt;))
    . . . convert TeX font change . . . )
  (method ((builder &lt;text-widget-converter&gt;) (token &lt;char&gt;))
    . . . convert text widget character . . . )
  (method ((builder &lt;text-widget-converter&gt;) (token &lt;font&gt;))
    . . . convert text widget font change . . . ))
</code></pre>

<p>Likewise, Exo-Lisps may be embedded within existing applications, like <a href="http://www.gnu.org/software/emacs/emacs-lisp-intro/">Emacs Lisp</a>, or act as extension frameworks like <a href="http://www.gnu.org/s/guile/">Guile</a>, <a href="http://usa.autodesk.com/adsk/servlet/index?siteID=13112&amp;id=770237">Visual Lisp</a> and <a href="http://sam.zoy.org/elk/">Elk</a>.</p>

<pre class="prettyprint lang-el"><code>;; Using Emacs Lisp to insert text around a region (Lee 2005)
(defun wrap-markup-region (start end)
"Insert a markup &lt;b&gt;&lt;/b&gt; around a region."
  (interactive "r")
  (save-excursion
    (goto-char end) (insert "&lt;/b&gt;")
    (goto-char start) (insert "&lt;b&gt;")))
</code></pre>

<p>Finally, Exo-Lisps like <a href="https://github.com/rvirding/lfe">LFE</a> and <a href="http://lambda-the-ultimate.org/node/2363">Liskell</a> serve as skins over the semantics of another language.</p>

<pre class="prettyprint lang-lisp"><code>;; Creating an Erlang process and sending it a message with LFE
(set say (lambda () 
           (receive 
             (msg (: io format '"'~s'~n" 
                               (list msg))))))
   
(set sayer (spawn (lambda () (funcall say))))
  
(! sayer "Hello Cleveland!")
</code></pre>

<p>While Exo-Lisps are often practical, they are not always used to build total systems.  Instead, the practical Lisps in the next section would most likely be used.</p>

<h2 id="practical-lisps">Practical Lisps</h2>

<p>Practicality is a relative term.  Having said that, there are clearly a set of Lisps that exist primarily to solve â€œreal worldâ€ <sup id="fnref:real"><a href="#fn:real" class="footnote">11</a></sup> problems and to typically build stand alone applications, including: <a href="http://common-lisp.net/">Common Lisp</a>, <a href="http://clojure.org">Clojure</a>, <a href="http://www.schemers.org/">Scheme (R5RS, R6RS, R7RS-big)</a>, <a href="http://racket-lang.org/">Racket</a>, <a href="http://www.call-cc.org/">Chicken Scheme</a>, and <a href="http://www.opendylan.org/">Dylan</a>.  </p>

<pre class="prettyprint lang-clj"><code>;; Using Clojure for street lane detection from 
;; video source -- elided (Nakkaya 2011)
(defn detect-edges [i]
  (--&gt; (convert-color i :bgr-gray)
     (smooth :gaussian 7 7 0 0)
       (canny 90 90 3)))

(defn process-frame [f w h]
(let [roi (copy-region f 0 50 w (- h 50))
        edges (detect-edges roi)
      points (points edges)
      lane  (map #(let [[x y] %] [x (+ y 50)]) 
             (filter (polygon points)))]
    (poly-line f lane java.awt.Color/blue 4)
  (release [roi edges])))
  
(let [capture (capture-from-file "StayingInLane_MPEG4.avi")
    frame-count (get-capture-property capture :frame-count)
    width (get-capture-property capture :frame-width)
    height (get-capture-property capture :frame-height)]
  (dotimes [_ frame-count]
  (let [frame (query-frame capture)]
    (process-frame frame width height)
      (view :raw frame)
    (Thread/sleep 10)))
  (release capture))
</code></pre>

<p>I'm tempting charges of libel by including this particular category and filling it with these particular choices, but so be it.</p>

<h2 id="kernel-lisps">Kernel Lisps</h2>

<p>I struggled to find a way of separating Exo-Lisps and Kernel Lisps and the following distinction arose from this struggle.  Where Exo-Lisps serve as a framework for a specific problem, Kernel Lisps serve as a framework for a more general problem  -- language or system development and experimentation.  Some examples of Kernel Lisps include: <a href="https://groups.google.com/forum/#!topic/comp.lang.scheme/MCfPoeir90s">R7RS-small</a>, <a href="http://s48.org">Scheme48</a>, <a href="http://common-lisp.net/project/bknr/static/lmman/frontpage.html">Lisp Machine Lisp</a>, <a href="http://people.bath.ac.uk/masjap/EuLisp/eulisp.html">EuLisp</a>, and <a href="http://www.gnu.org/software/kawa/">Kawa</a>.</p>

<pre class="prettyprint lang-lisp"><code>;; A ZetaLisp locking example
(unwind-protect
  (progn (process-lock sentinel)
    (do-something)
    (do-something-else))
  (process-unlock sentinel))
</code></pre>

<p>Perhaps I'm splitting hairs.</p>

<pre class="prettyprint lang-scm"><code>;; Defining a record type in Scheme-48
(define-record-type tuple :tuple
  (make-tuple ent attr val)
  tuple?
  (ent get-entity)
  (attr get-attribute)
  (val get-value))
</code></pre>

<p>The topic of Kernel Lisps could fill a volume of books (and has!), but a deeper exploration will need to wait until another day.</p>

<h2 id="pedagogical-lisps">Pedagogical Lisps</h2>

<p>As I alluded to earlier, the <a href="http://www.google.com/search?sourceid=chrome&amp;ie=UTF-8&amp;q=toy+lisp">Lisp landscape is rife with toys</a>, <a href="http://axisofeval.blogspot.com/2010/08/no-more-minimal-early-lisps-pulleezz.html">Ur-Lisps</a>, undergraduate interpreter projects and half implementations.</p>

<pre class="prettyprint lang-rb"><code># The base environment for an Ur-Lisp written in Ruby
@env = { 
 :label =&gt; proc { |(name,val), _| @env[name] = eval(val, @env) },
 :car   =&gt; lambda { |(list), _| list[0] },
 :cdr   =&gt; lambda { |(list), _| list.drop 1 },
 :cons  =&gt; lambda { |(e,cell), _| [e] + cell },
 :eq    =&gt; lambda { |(l,r),ctx| eval(l, ctx) == eval(r, ctx) },
 :if    =&gt; proc { |(c,t,e),ctx| eval(c, ctx) ? eval(t, ctx) : eval(e, ctx) },
 :atom  =&gt; lambda { |(s), _| (s.is_a? Symbol) or (s.is_a? Numeric) },
 :quote =&gt; proc { |sexpr, _| sexpr[0] } }
</code></pre>

<p>However, the vast majority of these Lisps exist for pedagogical pursuits and are rarely (if ever) overtly practical<sup id="fnref:overt"><a href="#fn:overt" class="footnote">12</a></sup>.  That's not to say that there is no value in pedagogical Lisps.  I'm a strong advocate of using small Lisp implementations as a programmer's fruit fly (i.e. a model â€œorganismâ€ for understanding languages and computation).</p>

<h2 id="fluchtpunkt-lisps">Fluchtpunkt Lisps</h2>

<p>The German school of Lisp is described by <a href="http://kazimirmajorinc.blogspot.com/2011/04/one-picolisp-snippet.html">Kazimir Majorinc</a> as a Spartan movement<sup id="fnref:mini"><a href="#fn:mini" class="footnote">13</a></sup> in Lisp implementation.<sup id="fnref:toys"><a href="#fn:toys" class="footnote">14</a></sup>  While I can agree with this categorization, I think that there's more to the German school than just one aspect.  In fact, I would say that to meet the criteria of the German school, a Lisp must take a philosophical stand in its implementation.</p>

<p>I'd like to propose a new term for the kinds of Lisps that fall into this â€œschoolâ€ classified largely by their Spartan natures.  </p>

<p>Recall the graphic from the beginning of this article:</p>

<p><img src="http://replove.herokuapp.com/images/lisps.png" alt="Lisps" title="The space between" /></p>

<p>This section deals with the crimson space between, affectionately referred to as <em>Fluchtpunkt Lisp</em>.</p>

<p>Fluchtpunkt Lisps skirt the vanishing point (in German, <em>der fluchtpunkt</em>) between theory, practicality and art.  These implementations are all of the other categories in some way, while simultaneously being none in particular.  These Lisps are not libraries nor do they typically have full-blown development ecosystems like the four higher-level categories outlined above.  They may or may not be general purpose languages in all instances, but they are <strong>all driven by a fervent ideal</strong>.  </p>

<p>Below is a list of Fluchtpunkt Lisp implementations that I've found, and some discussion of their driving ideal (as I understand):</p>

<h3 id="t">T</h3>

<p><a href="http://mumble.net/~jar/tproject/">http://mumble.net/~jar/tproject/</a></p>

<p>T is my favorite Scheme variant and the inspiration for many a Lisp/Scheme/Clojure thereafter.  I've poured over Stephen Slade's T book <sup id="fnref:t-book"><a href="#fn:t-book" class="footnote">15</a></sup> numerous times, finding something mind blowing each time.  The primary driving force behind T was to prove that a Scheme could be made to run extremely fast, and fast it ran.  T's compiler technology was the motivation for numerous dissertations, and remains influential in many ways, even if some of its compilation techniques have fallen out of fashion.  T had a notion of a first-class environment (called locales) that formed the basis of its dynamic module system.  However, one very important lesson in T was that its core was built from a set of base-objects and the implementation is a master-class in abstraction and API design.</p>

<pre class="prettyprint lang-scm"><code>;; An example of delay/force functions in T
;; from (Rees 1988)
  
(DEFINE-SYNTAX (DELAY EXP)                      &lt;1&gt;
  `(MAKE-DELAYED-OBJECT (LAMBDA () ,EXP)))

(DEFINE (MAKE-DELAYED-OBJECT THUNK)
  (LET ((FORCED-YET? NIL)
        (FORCED-VALUE NIL))
    (OBJECT NIL                                 &lt;2&gt;
            ((FORCE SELF)
             (COND ((NOT FORCED-YET?)
                    (SET FORCED-VALUE (THUNK))  &lt;3&gt;
                    (SET FORCED-YET? T)))
             FORCED-VALUE))))

(DEFINE-OPERATION (FORCE OBJ) OBJ)
</code></pre>

<ol>
  <li>A macro to avoid evaluation</li>
  <li><code>OBJECT</code> creates an anonymous class responding to a <code>FORCE</code> message</li>
  <li>Calling the <code>THUNK</code></li>
</ol>

<p>The names attached to T development is an all-star roster of langdev<sup id="fnref:langdev"><a href="#fn:langdev" class="footnote">16</a></sup> including, but not limited to: <a href="http://www.nhplace.com/kent/">Kent Pitman</a>, <a href="http://mumble.net/~jar/">Jonathan Rees</a>, <a href="http://mumble.net/~kelsey/">Richard Kelsey</a>, <a href="http://www.cs.yale.edu/people/hudak.html">Paul Hudak</a> and <a href="http://www.ccs.neu.edu/home/shivers/">Olin Shivers</a>.  T is an inspiration.</p>

<h3 id="shen">Shen</h3>

<p><a href="http://shenlanguage.org/">http://shenlanguage.org/</a></p>

<p>Shen (and its predecessor Qi) really pushes the limits of what we might call a Fluchtpunkt Lisp.  I suspect it requires a categorization of its own.  </p>

<p>A few years ago I was looking for a Lisp to dive into and my searching uncovered two extremely interesting options: Clojure and Qi.  I eventually went with Clojure, but in the intervening time I've managed to spend quality time with Qi and I love what I've seen so far.  Qi's confluence of features, including an optional type system (actually, its type system might be more accurately classified as â€œskinnableâ€), pattern matching,<sup id="fnref:patt"><a href="#fn:patt" class="footnote">17</a></sup> and an embedded logic engine based on Prolog, make it a very compelling choice indeed.</p>

<pre class="prettyprint lang-scm"><code>\\ Defining card rank and suit types using Shen
\\ from http://www.shenlanguage.org
  
(datatype rank
  if (element? X [ace 2 3 4 5 6 7 8 9 10 jack queen king])
  ________
  X : rank;)

(datatype suit
  if (element? Suit [spades hearts diamonds clubs])
  _________
  Suit : suit;)

(datatype card
  Rank : rank; Suit : suit;
  ==================
  [Rank Suit] : card;)
</code></pre>

<p>Aside from the type system and the embedded Prolog Shen also supports function definition as successive pattern matching forms.</p>

<pre class="prettyprint lang-scm"><code>(define get-suit
  {card --&gt; suit}
  [Rank Suit] -&gt; Suit)  &lt;1&gt;

(get-suit [2 hearts])

\\&gt; hearts : suit
</code></pre>

<ol>
  <li>Pattern match on the 2-tuple and return the right element</li>
</ol>

<p>There is also a book entitled <em>The Book of Shen</em> by the language's creator Mark Tarver available at <a href="http://www.fast-print.net/bookshop/1278/the-book-of-shen">http://www.fast-print.net/bookshop/1278/the-book-of-shen</a>.</p>

<h3 id="newlisp">newLISP</h3>

<p><a href="http://www.newlisp.org/">http://www.newlisp.org/</a></p>

<p>newLISP raised some ire at one point or another because of its design choices, specifically its choice of pervasive dynamic scope and <a href="http://www.wpi.edu/Pubs/ETD/Available/etd-090110-124904/unrestricted/jshutt.pdf">fexprs</a> (pdf).<sup id="fnref:fexprs"><a href="#fn:fexprs" class="footnote">18</a></sup>  I like dynamic scope under some circumstances, but I can't say that I've followed it to its logical end for any application of significant size or complexity.  The advocates of newLISP are interesting folk and in many ways of my own mind.  For example, how would one <a href="index.html">calculate Pi out to <code>n</code> digits in newLISP</a>?</p>

<pre class="prettyprint lang-lisp"><code>(define (pi n)
  (replace "\\" 
    (join                                        &lt;1&gt;
      (exec                                      &lt;2&gt;
        (format 
          "echo 'scale=%d; 4 * a(1)' | bc -ql"   &lt;3&gt;
          n)))
    ""))

(pi 30) 
;;=&gt; "3.1415926535897932384626433832795028841968"
</code></pre>

<ol>
  <li>Wait for the result from a child process</li>
  <li>Spawn a child process</li>
  <li>Build the UNIX command as a string</li>
</ol>

<p>Why you would call out to the UNIX <code>bc</code> command of course.</p>

<p>Why would you need your programming language to provide that type of calculation<sup id="fnref:mul"><a href="#fn:mul" class="footnote">19</a></sup> when there are more appropriate tools for doing so?  This is a question asked, and answered by newLISP. </p>

<p>I suppose the fundamental philosophy of newLISP is to not necessarily provide everything, but to make everything possible.  newLISP facilitates possibility by treating the use of <code>eval</code> as a first-class approach and utterly idiomatic.</p>

<h3 id="arc">Arc</h3>

<p><a href="http://www.paulgraham.com/arc.html">http://www.paulgraham.com/arc.html</a></p>

<p>I agonized over including Paul Graham's Arc in the category of Fluchtpunkt Lisp, but I think this is the correct place for it.  The driving forces behind Arc are <a href="http://www.paulgraham.com/power.html">succinctness</a> and <a href="http://www.paulgraham.com/hundred.html">centenarianism</a> -- both of which are certainly emblematic of the Fluchtpunkt ideal.  Arc hasn't taken off <a href="http://www.arclanguage.org/item?id=8462">as much as non-Paul-Graham humans would have liked</a>, but I believe that the root of the problem is that they prayed for practical, but instead got Fluchtpunkt.</p>

<pre class="prettyprint lang-scm"><code>;; The HackerNews source code for determining an article's rank 
;; on the front page, elided

(= gravity* 1.8 timebase* 120 front-threshold* 1 
   nourl-factor* .4 lightweight-factor* .3 )
 
(def frontpage-rank (s (o scorefn realscore) (o gravity gravity*))
  (* (/ (let base (- (scorefn s) 1)
          (if (&gt; base 0) (expt base .8) base))
        (expt (/ (+ (item-age s) timebase*) 60) gravity))
     (if (no (in s!type 'story 'poll))  1
         (blank s!url)                  nourl-factor*
         (lightweight s)                (min lightweight-factor* 
                                             (contro-factor s))
                                        (contro-factor s))))
</code></pre>

<p>In general, the development pace of Arc is slow and generally tied directly to changes required to keep Hacker News running, but a <a href="https://sites.google.com/site/arclanguagewiki/home">community of Arc fanatics</a> has taken the torch and created various implementations and references for Arc.</p>

<h3 id="picolisp">PicoLisp</h3>

<p><a href="http://www.picolisp.com/">http://www.picolisp.com/</a></p>

<p>I first came across PicoLisp when reading the paper <a href="http://software-lab.de/radical.pdf">â€œPico Lisp: A Radical Approach to Application Developmentâ€</a> by  Alexander Burger and was instantly fascinated.  The primary goal is to provide an idealized Lisp interpreter that runs as fast as possible.  To accomplish this goal PicoLisp limits its feature set and optimizes the code path along the dimensions of its features.  The core types provided by PicoLisp are numbers, symbols, and lists.  Given the paucity of these types PicoLisp has the advantage of always taking the most direct interpretation path and thus avoiding any unnecessary checks and abstractions that a more corpulent Lisp might require.  For example, PicoLisp's <code>quote</code> function is defined in such a way that it <a href="http://picolisp.com/5000/!wiki?ArticleQuote">returns all of its arguments unevaluated</a> allowing the operation of <code>quote</code> to optimize into only a return of its <code>cdr</code> rather than the <code>car</code> of its <code>cdr</code>.  Simple no?</p>

<p>Another interesting aspect of PicoLisp is that is does not contain strings, arrays, vectors nor anything but exactly numbers, symbols and lists as first-class data types.  It's drive is for simplicity <sup id="fnref:simpl"><a href="#fn:simpl" class="footnote">20</a></sup> in its offerings and possibilities as well as its implementation.  Aside from the practical matter that offering more data types means that there would be more type-specific functions, on the implementation side an increase in the  <a href="http://picolisp.com/5000/!wiki?ArrayAbstinence">number of tag-bits</a> is a limiting factor as well.  If you need a string, use a symbol.  If you need an array, use a list.  And so onâ€¦</p>

<p>Here is an example of some PicoLisp to scape a web-page:</p>

<pre class="prettyprint lang-lisp"><code>(load "@lib/http.l")
   
(client "replove.herokuapp.com" 80 "sakura/index.html" &lt;1&gt;
  (when (from "Pi Mu ")                                &lt;2&gt;
    (pack (trim (till "and")))))                       &lt;3&gt;

;;=&gt; (πㇺ)
</code></pre>

<ol>
  <li>Attach to the page using the built-in client library</li>
  <li>Start reading bytes from a given string</li>
  <li>Stop reading when it finds a different string</li>
</ol>

<p>PicoLisp is, in my opinion, the most interesting entry in a family of <em>really really small Lisps</em> that also includes <a href="http://www-fourier.ujf-grenoble.fr/~sergerar/Nanolisp/">Nanolisp</a> and <a href="http://code.google.com/p/femtolisp/">femtoLisp</a>, although I would hesitate to include these latter two in the Fluchtpunkt category. Even with its minimal data types, minimal scoping rules (dynamically scoped) and its favoring of <code>eval</code> over macros, PicoLisp still offers some interesting features like co-routines, first-class environments, and integrated database and Prolog (Pilog).</p>

<h3 id="wasp-lisp">Wasp Lisp</h3>

<p><a href="http://sites.google.com/site/waspvm/">http://sites.google.com/site/waspvm/</a></p>

<p>Wasp Lisp is a small Scheme inspired by Erlang with lightweight cooperative threads, communication via channels, and an implementation of <a href="http://bc.tech.coop/blog/061119.html">MOSREF</a>.  This latter feature is fairly interesting in that it allows one to create a network of â€œdroneâ€ Wasp VMs that can receive secure snippets of code from a remote console for execution.  </p>

<h2 id="what-is-fluchtpunkt">What is Fluchtpunkt?</h2>

<p>Fluchtpunkt Lisps areâ€¦</p>

<ol>
  <li><strong>Focused</strong>: Uncompromising in their vision</li>
  <li><strong>Spartan</strong>: Devoid of the seemingly unnecessary comforts found in many modern languages</li>
  <li><strong>Controversial</strong>: Not always by design, but often because of their design</li>
  <li><strong>Fun</strong></li>
</ol>

<p>I've taken a swing at a Fluchtpunkt Lisp or two, but haven't really put my heart into it -- and that's a problem because Fluchtpunkt Lisps require heart.</p>

<h1 id="a-language-that-doesnt-let-you-affect-the-way-it-thinks-is-not-worth-growing">A language that doesn't let you affect the way it thinks is not worth growing</h1>

<p>The differences between Common Lisp and Scheme are numerous and deep, but one difference that truly stands out to newcomers is summarized as their respective Lisp-2 and Lisp-1 natures.  In a sentence, Lisp-1 refers to a language that binds function values in the same namespace as any other values while a Lisp-2 binds function values in a separate namespace from other kinds of values.  The mechanics of <sup id="fnref:lisp-n"><a href="#fn:lisp-n" class="footnote">21</a></sup> namespacing are not important for this section, but I'll probably talk about it more in future installments.</p>

<p>One way that this difference manifests itself is in endless, mostly pedantic Usenet threads and blog posts.  However, the other manifestation is in the way that higher-order and first-class functions are built.  Take for example a <code>best</code> function implemented in Common Lisp that takes a function and a list and returns the â€œbestâ€ value based on the pairwise criteria encoded in the given function:</p>

<pre class="prettyprint lang-lisp"><code>;; Common Lisp -- bad example

(defun best (fun list)
  (reduce (lambda (x y) 
            (if (fun x y) x y))
          list))
</code></pre>

<p>When the <code>best</code> function is called with a function value it is bound to the name <code>fun</code>.  However, Common Lisp has careful logic around how it looks up an operator (the thing at the head of a list).  That is, Common Lisp will look at the <em>name</em> <code>fun</code> rather than its value and attempt to look it up in the function namespace rather than resolving its value.  You're not likely to have a <code>best</code> function available, so attempting to call it as written above will failed with a function-lookup-error.  Instead, if the above were Scheme code (with a slightly different function definition syntax) then everything would work as expected.</p>

<p>The correct way to write <code>best</code> is as follows:</p>

<pre class="prettyprint lang-lisp"><code>;; Common Lisp

(defun best (fun list)
  (reduce (lambda (x y) 
            (if (funcall fun x y) x y))
          list))
</code></pre>

<p>Instead of placing <code>fun</code> at the head of a list the new implementation calls its value (hopefully a function) via the <code>funcall</code> function.  Common Lisp's <code>funcall</code> will indeed resolve the value of <code>fun</code> via normal argument evaluation and â€œdo the right thing,â€ as shown below:</p>

<pre class="prettyprint lang-lisp"><code>(best #'&gt; '(1 2 3 4 5 6 -1))
;;=&gt; 6
</code></pre>

<p>Now something that might jump out at you if you're not familiar with Common Lisp is that the greater-than function <code>&gt;</code> is passed using the <code>#'</code> prefix.  This prefix tells Common Lisp that a value passed is indeed a function and as a result its value should be obtained from the function namespace.</p>

<p>This drives Scheme programmers crazy.  That is, the extra ceremony around passing and calling functions is viewed as inelegant by many in the Scheme community.  Whether you agree with this view or not is not the point however.  Instead, I'd like to show that Common Lisp is flexible enough to facilitate a more Scheme-like ideal.</p>

<h2 id="evolutionary-by-design">Evolutionary by design</h2>

<p>Common Lisp is a language that can host its own evolution.  That is, if you wish to make Common Lisp into a language of your dreams then you need only mold it into that language.  Have you ever wondered why the Common Lisp standard has not changed in so many years?  The straight answer is that it doesn't need to.  Instead, the standard defines Common Lisp in such a way as to allow language-level evolution in addition to not standing in the way of vendor-specific enhancements.  This stands in stark contrast to many programming language standards that define a specific language's capabilities in fixed terms.</p>

<p>One feature of Common Lisp that provides an edge in evolution over many (most?) languages is its <code>macrolet</code> special operator.  In short, <code>macrolet</code> defines a lexical block (like <code>let</code>) whereby expansions of embedded macros occur based on the local macro binds.  Observe a very simple use of <code>macrolet</code>:</p>

<pre class="prettyprint lang-lisp"><code>(macrolet ((sq (n) `(* ~n ~n)))
  (sq 10))
;;=&gt; 100
</code></pre>

<p>The expansion of the code above would be:</p>

<pre><code>(* 10 10)
</code></pre>

<p>Pretty straight-forward no?  </p>

<p>Now, using <code>macrolet</code> I can create a macro named <code>schemish</code><sup id="fnref:scm-macro"><a href="#fn:scm-macro" class="footnote">22</a></sup> that takes a list of names and locally rewrites their invocations to occur through <code>funcall</code>.  That is, the following:</p>

<pre><code>(schemish (fun)
  (fun 10))
</code></pre>

<p>Would be expanded locally into:</p>

<pre class="prettyprint lang-lisp"><code>(funcall fun 10)
</code></pre>

<p>The implementation of <code>schemish</code> is as follows:</p>

<pre class="prettyprint lang-lisp"><code>(defmacro schemish (functions &amp;body body)
  `(macrolet ,(mapcar (lambda (function)
                `(,function (&amp;rest args)
                   `(funcall ,',function ,@args)))
                functions)
      ,@body))
</code></pre>

<p>The use of <code>mapcar</code> in the implementation above builds a <code>macrolet</code> compatible bindings expression that binds any names as local macros that themselves expand into calls of the functions through <code>funcall</code>.  It's best to show an expansion:</p>

<pre class="prettyprint lang-lisp"><code>(macroexpand '(schemish (fun) (fun 42)))

;;=&gt; (MACROLET ((FUN (&amp;REST ARGS) 
;;                (FUNCALL FUN ARGS)))
;;     (FUN 42))
</code></pre>

<p>Thus fully expanded, (you might see something different if you run it in your chosen REPL) the code above looks similar to the previous use of <code>macrolet</code> and <code>sq</code>.  Now, I can use <code>schemish</code> to avoid explicit use of <code>funcall</code> and (hopefully) placate some of the Scheme adherents:</p>

<pre class="prettyprint lang-lisp"><code>(defun best (fun list)
  (schemish (fun)
    (reduce (lambda (x y) (if (fun x y) x y))
            list)))
</code></pre>

<p>And the use of the new <code>best</code> implementation is as follows:</p>

<pre class="prettyprint lang-lisp"><code>(best #'&gt; '(1 2 3 4 5 -1))
;;=&gt; 5

(best '&lt; '(1 2 3 4 5 -1))
;;=&gt; -1
</code></pre>

<p>One point of note in the examples above is that the symbol <code>&lt;</code> was resolved to the correct function automatically.  This is a feature of <code>funcall</code> itself.  One character saved!</p>

<h2 id="conclusion">Conclusion</h2>

<p>Both the Common Lisp and Scheme standards make fundamental decisions that define core precepts that define their behaviors and in many ways attract certain kinds of programmers.<sup id="fnref:nope"><a href="#fn:nope" class="footnote">23</a></sup>  Additionally, both Scheme and Common Lisp allow degrees of language evolution through various means.  However, in my opinion there are no languages<sup id="fnref:hmmm"><a href="#fn:hmmm" class="footnote">24</a></sup> in operation today that provide the flexibility and self-hosted evolution provided by Common Lisp.</p>

<h1 id="eating-parentheses-for-breakfast-is-delicious-and-fun">Eating parentheses for breakfast is deliciousâ€¦ and fun!</h1>

<p><em>A review of <a href="http://www.amazon.com/dp/1593272812/?tag=fogus-20">Land of Lisp</a> by Dr. Conrad Barski.</em></p>

<p><img src="http://farm3.staticflickr.com/2838/9714326273_05567da772_o.png" width="303" height="400" alt="lol"></p>

<p>If for no other reason, you should <a href="http://www.amazon.com/dp/1593272812/?tag=fogus-20">buy Land of Lisp</a> because of the extreme levels of unadulterated nerdery filling its pages. The price of the book is almost worth that very spectacle alone. However, as an added bonus the content of the book is top drawer. The first incarnation of Lisp was discovered by John McCarthy over 50 years ago, so it's difficult to imagine that a book on the subject bringing a fresh perspective, but Land of Lisp pulls it off in spades. The book manages to carve its own unique niche in the Lisp book landscape through a masterful blend of cartoons, game development examples, interesting prose, and a highly sharpened whit.</p>

<p><img src="http://replove.herokuapp.com/images/dialect.png" alt="One of the many laugh-out-loud moments" /></p>

<p>The author, <a href="http://landoflisp.com/">Conrad Barski M.D.</a>, takes the reader through a whirlwind tour of Common Lisp and some of the fundamental principles of game development, but interestingly enough it never feels rushed. He accomplishes this feat by sticking to a very important strategy summarized as, â€œproviding something useful at every stageâ€. That is, every example in the book is meant to fit into the context of the larger game examples (e.g. a text adventure, Dice of Doom, etc.) while simultaneously teaching a lesson about Common Lisp <em>and</em> provide utility in isolation. It's really a thing of beauty the way that Mr. Barski manages to build usable games piecemeal while teaching important concepts along the way. To illustrate what I mean, let me give an example.</p>

<p>The Dice of Doom game<sup id="fnref:games"><a href="#fn:games" class="footnote">25</a></sup> example starts with a very small 2x2 board and the program parts needed to represent it. Mr. Barski then builds pieces on top of this substrate to generate positions, while extolling the virtues of decoupling the logic of the game from its representation. It's at this point that the game is playable against a human opponent, but at no previous stage was the code left in a state of flux -- each one was fully amenable to tinkering, tweaking, and experimentation. As an added bonus, the whole implementation by this stage was an incredible 13 lines! (that is actually not true, it's more than that, but by using Common Lisp the implementation was incredibly concise) As if this feat was not impressive enough, Mr. Barski then adds game AI into the mix while explaining the famous minimax search algorithm. He then makes the game more efficient using some techniques common in functional programming, including: closures, memoization, tail-calls (with caveats), and lazy programming. As expected the game itself becomes more feature rich as these lessons progress as stronger AI (i.e. better evaluation) is added, more efficient search techniques are introduced (i.e. alpha-beta pruning), and heuristics are used.</p>

<p>All in all, I am very impressed with the quality of Land of Lisp and consider it one of the best Common Lisp book available today. As a <a href="http://www.joyofclojure.com">co-author of a Clojure programming book</a> I appreciate the amount of effort required to pull off a genuinely unique book -- I would be happy to achieve a fraction of the quality of Land of Lisp. This book will appeal to the long-time Lisper and the neophyte and I highly recommend buying it today.</p>

<h1 id="fun">Fun</h1>

<blockquote>
  <p>These things are fun, and fun is good.
 Dr. Seuss</p>
</blockquote>

<p>This section contains odd-ball entries that do not fit anywhere else.  All bets are off for strict adherence to the theme.  The only constant herein is that you shouldn't take things too seriously.</p>

<h2 id="voices-from-the-apple">Voices from the Apple</h2>

<p>Apple once had a brilliant marketing campaign famously known as â€œWheels for the mind.â€  The starkly simple, yet powerful image that went along with that phrase was as follows:</p>

<p><img src="http://replove.herokuapp.com/images/wftm.jpg" alt="Wheels for the Mind" /></p>

<p>This particular ad was run in 1981 and referred directly to the <a href="http://apple2history.org/">Apple II line of computers</a>.  However, even after that ad ran its course the company designed and developed amazing technologies that truly did serve as â€œwheels for the mind,â€ including, but not limited to the following.</p>

<h3 id="macintosh-common-lisp-mcl">Macintosh Common Lisp (MCL)</h3>

<p><a href="ftp://ftp.informatimago.com/pub/lisp/macintosh-common-lisp-reference.pdf">ftp://ftp.informatimago.com/pub/lisp/macintosh-common-lisp-reference.pdf</a> (PDF)</p>

<p>MCL is/was a standards-compliant version of Common Lisp with a very powerful IDE for creating Macintosh applications.</p>

<h3 id="hypercard">Hypercard</h3>

<p><a href="http://hypercard.org/">http://hypercard.org/</a></p>

<p>An early hypermedia development language and platform that was a revelation for many people who used it.  With a little extra context here and perhaps a little luck there, Hypercard might have served as the basis for the World Wide Web, rather than simply an inspiration.  As it stands, it's commonly believed that the direction of the WWW in contrast to Hypercard's limited viewpoint was its downfall.  However, Stanislav Datskovskiy <sup id="fnref:why-die"><a href="#fn:why-die" class="footnote">26</a></sup> makes a different case altogether -- one that you'll more fully understand at the punchline of this segment.</p>

<h3 id="dylan">Dylan</h3>

<p><a href="http://opendylan.org/">http://opendylan.org/</a></p>

<p>Dylan is a Lisp-like object-oriented programming language originally designed as a <a href="http://oldcomputers.net/apple-newton.html">Newton</a> development system.  While Dylan is still actively maintained and used, it's ongoing evolution was divorced from Apple long ago.</p>

<p>These languages were, and are, amazing and important entries in the annals of langdev -- so is it any surprise that they found their start at Apple?  Probably not. However, that they've been allow to die and been excised from their roots is sad, but perhaps not too surprising given the direction of Apple products over the past ~10 years.</p>

<h3 id="wheels-of-a-sort">Wheels of a sort</h3>

<p>Each of the languages listed above were ahead of their time and offered first-class development environments for the Apple line of computers and systems.  However, over time Apple eventually phased out each and every one and indeed the very computers that they targeted.  From the start, the Apple I and early versions of the Apple II computers were software and hardware extensible and for many a young man or woman were truly â€œwheels for the mind.â€  </p>

<p>Sadly, had Apple simply phased out old hardware and development systems in favor of something new and more powerful then few would have shed a tear.  Instead, Apple moved away from the very notion of â€œwheels of the mindâ€ in favor of building systems for consumers.  Objective C, the iPad and iCloud are no longer â€œwheels for the mindâ€ but are instead simply â€œtraining wheels for the mind.â€</p>

<p><img src="http://replove.herokuapp.com/images/twftm.jpg" alt="Training wheels for the mind" /></p>

<p>Tools for getting a job done.</p>

<p>Tools for viewing trivialities.</p>

<p>Tools for tools?</p>

<h2 id="matters-of-perspective">Matters of perspective</h2>

<p>The long-standing trench-warfare between Common Lispers and Schemers has claimed many a pride as casualties.  While the â€œsoldiersâ€ have grown weary over the years, the fundamental differences between the two camps can be summarized as in the following relativistic lexicon.</p>

<table>
  <thead>
    <tr>
      <th>Term</th>
      <th>Common Lisp</th>
      <th>Scheme</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Hygiene<sup id="fnref:flet"><a href="#fn:flet" class="footnote">27</a></sup></td>
      <td>Always use earmuffs and wisely use <code>FLET</code> and <code>LABELS</code></td>
      <td>Macros, the Scheme way</td>
    </tr>
    <tr>
      <td>proper tail-calls</td>
      <td>Function with no bugs having calls in the tail position</td>
      <td><em>no definition</em></td>
    </tr>
    <tr>
      <td>Proper Tail-Calls</td>
      <td><em>no definition</em></td>
      <td>Tail-calls, the Scheme way</td>
    </tr>
    <tr>
      <td>Tail-call elimination</td>
      <td>A vendor-specific feature</td>
      <td>Porting SCM code to CL</td>
    </tr>
    <tr>
      <td>Higher-order thinking</td>
      <td>Remembering to use <code>#'</code></td>
      <td>Remembering to use Scheme</td>
    </tr>
    <tr>
      <td>Higher-order function</td>
      <td>One taking or returning other functions</td>
      <td>The conceptual Maginot Line</td>
    </tr>
    <tr>
      <td>Lisp-1</td>
      <td>The index entry before Lisp-2</td>
      <td>The definition of beauty</td>
    </tr>
    <tr>
      <td>Lisp-2</td>
      <td>The index entry before Lisp-3</td>
      <td>The definition of ugly</td>
    </tr>
  </tbody>
</table>

<h2 id="links-source-posts-pictures-papers-music-and-more">Links, source, posts, pictures, papers, music and more</h2>

<ul>
  <li>(BOOK) <a href="http://www.amazon.com/dp/1593272812/?tag=fogus-20">Land of Lisp by Conrad Barski</a></li>
  <li>(BOOK) <a href="http://repository.readscheme.org/ftp/papers/t_manual.pdf">The T manual</a> by Rees, Adams, and Meehan (PDF)</li>
  <li>
    <p>(BOOK) <a href="http://www.cs.berkeley.edu/~bh/ss-toc2.html">Simply Scheme: Introducing Computer Science</a> by Brian Harvey and Matthew Wright</p>
  </li>
  <li>(CODE) <a href="https://github.com/nicferrier/emacs-ejit">Javascript compiler for EmacsLisp</a> by Nic Ferrier</li>
  <li>(CODE) [A teeny-tiny Markdown parser in Clojure](https://github.</li>
  <li>
    <p>(CODE) <a href="http://nakkaya.com/2011/01/24/lane-detection-using-clojure-and-opencv/">Lane Detection using Clojure and OpenCV</a></p>
  </li>
  <li>
    <p>(MUSIC) <a href="http://www.restingbell.net/releases/rb081-bow-echoes">Bow Echoes by Damian Valles</a></p>
  </li>
  <li>
    <p>(PAPER) <em>Advanced Programming Language Features for Executable Design Patterns: Better Patterns Through Reflection</em> by Gregory T. Sullivan</p>
  </li>
  <li>(TUTORIAL) <a href="http://www.greghendershott.com/fear-of-macros/">GregHendershott's Fear of Macros</a>
com/chameco/Hitman/blob/master/src/hitman/core.clj)</li>
  <li>(TUTORIAL) <a href="http://ergoemacs.org/emacs/elisp_examples.html">Emacs Lisp Examples</a> by Xah Lee</li>
</ul>

<h1 id="finally">Finally</h1>

<p>If you've enjoyed this installment of Read-Eval-Print-λove then please consider buying the PDF / mobi / epub versions on Leanpub at <a href="https://leanpub.com/readevalprintlove001">https://leanpub.com/readevalprintlove001</a>, paying whatever you think it's worth.</p>

<p>I'd like to thank Xach Beane for the AutoMotivator webapp used to create the Erik Naggum image and Conrad Barski for the â€œAlien technologyâ€ images.  I'd also like to thank Craig Andera and Russ Olsen for reviewing a draft of this issue.  Also, Read-Eval-Print-λove's spirit is inspired by the beautiful works of Kragen Javier Sitaker.  Finally, the cover of this issue was painted by my mother-in-law Kiyomi Okada.</p>

<p>Is there something that you'd like to see in future issues?  Email me at the address below with suggestions.  If you'd like to discuss this issue of Read-Eval-Print-λove then head on over to <a href="http://www.lispforum.com">http://www.lispforum.com</a> or the LL.next mailing list at <a href="https://groups.google.com/forum/#!forum/ll-next">https://groups.google.com/forum/#!forum/ll-next</a> -- I'll be there.</p>

<p>The tentative release date for issue #2 is sometime in late October or early November, 2013.  The theme for issue #2 is â€œOrientation around objects.â€</p>

<div class="footnotes">
  <ol>
    <li id="fn:toil">
      <p>Not nearly as rigorous as Pi Mu's however. <a href="#fnref:toil" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:repl">
      <p>Think REPL. <a href="#fnref:repl" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:more-lisp">
      <p>I'll come back to this list in future installments. Stay tuned. <a href="#fnref:more-lisp" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:lua">
      <p>Lua is very close to meeting all of the requirements above and with <a href="http://metalua.luaforge.net/">MetaLua</a> is darn near complete. <a href="#fnref:lua" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:std">
      <p>A reliance on the Common Lisp standard for language definition leads me to believe that <code>eval</code> is an insufficient mechanism for describing the nuances of CL. <a href="#fnref:std" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:clway">
      <p>To the extent that Common Lisp has or supports a â€œway.â€ <a href="#fnref:clway" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:scmnot">
      <p>There was an epic thread on the comp.lang.lisp Usenet list circa 2002 involving part trolling, part rage and part wisdom entitled <em><a href="https://groups.google.com/forum/#!topic/comp.lang.lisp/Bj8Hx6mZEYI">Why Scheme is not a Lisp?</a></em>.  It's well worth exploring that thread for a deeper understanding of just what constitutes a Lisp and how Internet communications will be the death of us all. <a href="#fnref:scmnot" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:idont">
      <p>I don't really care, but I'll still try to use the terms â€œLisp familyâ€ vs. â€œLittle languageâ€ vs. some other terms to make a distinction. <a href="#fnref:idont" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:zine">
      <p>The tern â€œzineâ€ is a bit archaic, but I've not thought of a better term for what this is.  I was considering â€œxineâ€, but that's not really satisfactory either. <a href="#fnref:zine" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:revisited">
      <p>This is an expanded and updated version of an <a href="http://blog.fogus.me/2011/05/03/the-german-school-of-lisp-2/">earlier article â€œThe German School of Lispâ€ from 2011</a>. <a href="#fnref:revisited" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:real">
      <p>I really hesitate to use the term â€œreal worldâ€ because it's often used to categorize highly fashionable or mainstream jobs or markets.  However, <em>my</em> â€œreal-worldâ€ involves distributed simulations and production rules systems, two somewhat specialized fields.  Sadly, I think that â€œreal worldâ€ is a place where programmers retreat to avoid learning something new and possibly challenging. <a href="#fnref:real" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:overt">
      <p>However, toy and Ur-Lisps are practical insomuch as the act of implementing them is good programming practice. <a href="#fnref:overt" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:mini">
      <p>I intentionally avoid the word â€œminimalâ€ in this post.  Spartan is Mr. Majorinc's word, and I think it is more appropriate. <a href="#fnref:mini" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:toys">
      <p>But let me be clear, the Lisps in this section are not toys like the ones littering the Lisp landscape (including, and especially, my own: <a href="http://github.com/fogus/lithp">Lithp</a> and <a href="http://github.com/fogus/ulithp">Î¼Lithp</a>). <a href="#fnref:toys" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:t-book">
      <p>http://www.amazon.com/o/asin/013881905X?tag=fogus-20 <a href="#fnref:t-book" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:langdev">
      <p>Programming language development. <a href="#fnref:langdev" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:patt">
      <p>I miss pattern matching.  <code>clojure.core.match</code>, wherefore art thou? <a href="#fnref:patt" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:fexprs">
      <p>Regardless of the chances of bringing a libel suit on myself, I will say that fexprs are effectively runtime macros.  <a href="#fnref:fexprs" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:mul">
      <p>Well, you could also use <code>(mul 4 (atan 1))</code> if you didn't care about precision. :p <a href="#fnref:mul" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:simpl">
      <p>The word â€œsimpleâ€ is used in a loose way throughout this issue and is not tied to its dual â€œentangledâ€ nor â€œcomplected.â€ <a href="#fnref:simpl" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:lisp-n">
      <p>Common Lisp has many more than two namespaces for binding certain values to names.  I could (and probably will) write a whole issue on just this topic. <a href="#fnref:lisp-n" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:scm-macro">
      <p>The <code>schemish</code> macro is taken wholly from Erik Naggum (at https://groups.google.com/forum/#!topic/comp.lang.lisp/Bj8Hx6mZEYI%5B101-125) with the name changed for giggles.  I also removed his use of <code>locally</code> as I didn't want to get into a discussion of why it was or wasn't needed.  It's worth reading the original message for additional illumination.  You can enhance your reading by exploring his original code and my changes at <a href="http://ideone.com/axfTIQ">http://ideone.com/axfTIQ</a>. <a href="#fnref:scm-macro" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:nope">
      <p>I'll not discuss the â€œkindsâ€ at all.  Sorry. <a href="#fnref:nope" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:hmmm">
      <p>Debatable. <a href="#fnref:hmmm" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:games">
      <p>As a fan of simple games in the Looney Labs vein, (dare I say, Fluchtpunkt games?) I appreciate the games included in the book.  Not only are they informative, but they're also fun to play. <a href="#fnref:games" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:why-die">
      <p>http://www.loper-os.org/?p=568 <a href="#fnref:why-die" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:flet">
      <p>I understand how packages and the restrictions on the core symbols help here -- let me have some fun please. <a href="#fnref:flet" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

		    </div>
		    <div class="stunning-text-corner top"></div>
		    <div class="stunning-text-corner bottom"></div>
		    <div class="clear"></div>
		  </div>
		</div>
      </div>
    </div>
    <br class="clear">
  </div>
</div>
    </div>
    <div class="footer-wrapper">
      <div class="container">
	<div class="footer-widget-wrapper">
	  <div class="one-third column mt0">
	    <div class="custom-sidebar gdl-divider">
	      &nbsp;
	      <div class="clear"></div>
	    </div>
	  </div>
	</div>
	<div class="one-third column mt0">
	  <div class="custom-sidebar gdl-divider">
	    <h3 class="custom-sidebar-title footer-title-color gdl-title">Entries</h3>
	    <div class="tagcloud">
	      <a href="sakura/index.html" class="glossary-link" style="font-size: 8pt;">sakura</a>
	    </div>
	  </div>
	</div>
	<div class="one-third column mt0">
	  <div class="custom-sidebar gdl-divider">
	    <h3 class="custom-sidebar-title footer-title-color gdl-title">About the author</h3>
	    <div class="textwidget">
	      <div style="clear:both; height:6px"></div>
	        
<p><a href="http://www.fogus.me">Michael Fogus</a> â€” a core contributor to
<a href="http://www.clojure.org">Clojure</a> and <a href="http://www.clojurescript.net">ClojureScript</a>.  Creator of <a href="https://www.github.com/fogus">programming source codes</a>.</p>

<p>A fervent blogger at <a href="http://blog.fogus.me">Send More Paramedics</a> and also
co-author of the book, <em><a href="http://www.joyofclojure.com">The Joy of Clojure</a></em> and author of <em><a href="http://www.functionaljavascript.com">Functional JavaScript</a></em>.</p>

  	      </div>
	  </div>
	  <div class="custom-sidebar gdl-divider">
	    <h3 class="custom-sidebar-title footer-title-color gdl-title">Author online</h3>
	    <div class="textwidget">
          
<ul>
  <li><a href="http://www.fogus.me">http://www.fogus.me</a></li>
  <li><a href="http://www.twitter.com/fogus">http://www.twitter.com/fogus</a></li>
  <li><a href="https://www.github.com/fogus">https://www.github.com/fogus</a></li>
  <li>me -at- fogus -dot- me</li>
</ul>

<p><strong>Discussion and information</strong></p>

<ul>
  <li><a href="http://www.readevalprintlove.org">http://www.readevalprintlove.org</a></li>
  <li><a href="https://www.github.com/readevalprintlove">https://www.github.com/readevalprintlove</a></li>
  <li><a href="http://www.lispforum.com/">http://www.lispforum.com/</a></li>
  <li><a href="https://groups.google.com/forum/#!forum/ll-next">https://groups.google.com/forum/#!forum/ll-next</a></li>
</ul>

	    </div>
	  </div>
	</div>
      </div>
      <div class="display-none mt0"></div>
      <br class="clear">
    </div>
</div>
<div class="copyright-wrapper">
  <div class="container">
    Â© Copyright 2013, Michael Fogus
  </div>
</div>
</div><!-- footer-wrapper -->
</div> <!-- body-wrapper -->

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-921112-2");
pageTracker._trackPageview();
} catch(err) {}
</script>
<script type="text/javascript">
window.onload = function() {
  document.getElementById("body").focus();
};
</script>

</body>
</html>